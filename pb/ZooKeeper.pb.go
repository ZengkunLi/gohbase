// Code generated by protoc-gen-go.
// source: ZooKeeper.proto
// DO NOT EDIT!

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SplitLogTask_State int32

const (
	SplitLogTask_UNASSIGNED SplitLogTask_State = 0
	SplitLogTask_OWNED      SplitLogTask_State = 1
	SplitLogTask_RESIGNED   SplitLogTask_State = 2
	SplitLogTask_DONE       SplitLogTask_State = 3
	SplitLogTask_ERR        SplitLogTask_State = 4
)

var SplitLogTask_State_name = map[int32]string{
	0: "UNASSIGNED",
	1: "OWNED",
	2: "RESIGNED",
	3: "DONE",
	4: "ERR",
}
var SplitLogTask_State_value = map[string]int32{
	"UNASSIGNED": 0,
	"OWNED":      1,
	"RESIGNED":   2,
	"DONE":       3,
	"ERR":        4,
}

func (x SplitLogTask_State) Enum() *SplitLogTask_State {
	p := new(SplitLogTask_State)
	*p = x
	return p
}
func (x SplitLogTask_State) String() string {
	return proto.EnumName(SplitLogTask_State_name, int32(x))
}
func (x *SplitLogTask_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SplitLogTask_State_value, data, "SplitLogTask_State")
	if err != nil {
		return err
	}
	*x = SplitLogTask_State(value)
	return nil
}
func (SplitLogTask_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor27, []int{3, 0} }

type SplitLogTask_RecoveryMode int32

const (
	SplitLogTask_UNKNOWN       SplitLogTask_RecoveryMode = 0
	SplitLogTask_LOG_SPLITTING SplitLogTask_RecoveryMode = 1
	SplitLogTask_LOG_REPLAY    SplitLogTask_RecoveryMode = 2
)

var SplitLogTask_RecoveryMode_name = map[int32]string{
	0: "UNKNOWN",
	1: "LOG_SPLITTING",
	2: "LOG_REPLAY",
}
var SplitLogTask_RecoveryMode_value = map[string]int32{
	"UNKNOWN":       0,
	"LOG_SPLITTING": 1,
	"LOG_REPLAY":    2,
}

func (x SplitLogTask_RecoveryMode) Enum() *SplitLogTask_RecoveryMode {
	p := new(SplitLogTask_RecoveryMode)
	*p = x
	return p
}
func (x SplitLogTask_RecoveryMode) String() string {
	return proto.EnumName(SplitLogTask_RecoveryMode_name, int32(x))
}
func (x *SplitLogTask_RecoveryMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SplitLogTask_RecoveryMode_value, data, "SplitLogTask_RecoveryMode")
	if err != nil {
		return err
	}
	*x = SplitLogTask_RecoveryMode(value)
	return nil
}
func (SplitLogTask_RecoveryMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor27, []int{3, 1}
}

// Table's current state
type DeprecatedTableState_State int32

const (
	DeprecatedTableState_ENABLED   DeprecatedTableState_State = 0
	DeprecatedTableState_DISABLED  DeprecatedTableState_State = 1
	DeprecatedTableState_DISABLING DeprecatedTableState_State = 2
	DeprecatedTableState_ENABLING  DeprecatedTableState_State = 3
)

var DeprecatedTableState_State_name = map[int32]string{
	0: "ENABLED",
	1: "DISABLED",
	2: "DISABLING",
	3: "ENABLING",
}
var DeprecatedTableState_State_value = map[string]int32{
	"ENABLED":   0,
	"DISABLED":  1,
	"DISABLING": 2,
	"ENABLING":  3,
}

func (x DeprecatedTableState_State) Enum() *DeprecatedTableState_State {
	p := new(DeprecatedTableState_State)
	*p = x
	return p
}
func (x DeprecatedTableState_State) String() string {
	return proto.EnumName(DeprecatedTableState_State_name, int32(x))
}
func (x *DeprecatedTableState_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DeprecatedTableState_State_value, data, "DeprecatedTableState_State")
	if err != nil {
		return err
	}
	*x = DeprecatedTableState_State(value)
	return nil
}
func (DeprecatedTableState_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor27, []int{4, 0}
}

// *
// Content of the meta-region-server znode.
type MetaRegionServer struct {
	// The ServerName hosting the meta region currently, or destination server,
	// if meta region is in transition.
	Server *ServerName `protobuf:"bytes,1,req,name=server" json:"server,omitempty"`
	// The major version of the rpc the server speaks.  This is used so that
	// clients connecting to the cluster can have prior knowledge of what version
	// to send to a RegionServer.  AsyncHBase will use this to detect versions.
	RpcVersion *uint32 `protobuf:"varint,2,opt,name=rpc_version,json=rpcVersion" json:"rpc_version,omitempty"`
	// State of the region transition. OPEN means fully operational 'hbase:meta'
	State            *RegionState_State `protobuf:"varint,3,opt,name=state,enum=pb.RegionState_State" json:"state,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *MetaRegionServer) Reset()                    { *m = MetaRegionServer{} }
func (m *MetaRegionServer) String() string            { return proto.CompactTextString(m) }
func (*MetaRegionServer) ProtoMessage()               {}
func (*MetaRegionServer) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{0} }

func (m *MetaRegionServer) GetServer() *ServerName {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *MetaRegionServer) GetRpcVersion() uint32 {
	if m != nil && m.RpcVersion != nil {
		return *m.RpcVersion
	}
	return 0
}

func (m *MetaRegionServer) GetState() RegionState_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return RegionState_OFFLINE
}

// *
// Content of the master znode.
type Master struct {
	// The ServerName of the current Master
	Master *ServerName `protobuf:"bytes,1,req,name=master" json:"master,omitempty"`
	// Major RPC version so that clients can know what version the master can accept.
	RpcVersion       *uint32 `protobuf:"varint,2,opt,name=rpc_version,json=rpcVersion" json:"rpc_version,omitempty"`
	InfoPort         *uint32 `protobuf:"varint,3,opt,name=info_port,json=infoPort" json:"info_port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Master) Reset()                    { *m = Master{} }
func (m *Master) String() string            { return proto.CompactTextString(m) }
func (*Master) ProtoMessage()               {}
func (*Master) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{1} }

func (m *Master) GetMaster() *ServerName {
	if m != nil {
		return m.Master
	}
	return nil
}

func (m *Master) GetRpcVersion() uint32 {
	if m != nil && m.RpcVersion != nil {
		return *m.RpcVersion
	}
	return 0
}

func (m *Master) GetInfoPort() uint32 {
	if m != nil && m.InfoPort != nil {
		return *m.InfoPort
	}
	return 0
}

// *
// Content of the '/hbase/running', cluster state, znode.
type ClusterUp struct {
	// If this znode is present, cluster is up.  Currently
	// the data is cluster start_date.
	StartDate        *string `protobuf:"bytes,1,req,name=start_date,json=startDate" json:"start_date,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ClusterUp) Reset()                    { *m = ClusterUp{} }
func (m *ClusterUp) String() string            { return proto.CompactTextString(m) }
func (*ClusterUp) ProtoMessage()               {}
func (*ClusterUp) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{2} }

func (m *ClusterUp) GetStartDate() string {
	if m != nil && m.StartDate != nil {
		return *m.StartDate
	}
	return ""
}

// *
// WAL SplitLog directory znodes have this for content.  Used doing distributed
// WAL splitting.  Holds current state and name of server that originated split.
type SplitLogTask struct {
	State            *SplitLogTask_State        `protobuf:"varint,1,req,name=state,enum=pb.SplitLogTask_State" json:"state,omitempty"`
	ServerName       *ServerName                `protobuf:"bytes,2,req,name=server_name,json=serverName" json:"server_name,omitempty"`
	Mode             *SplitLogTask_RecoveryMode `protobuf:"varint,3,opt,name=mode,enum=pb.SplitLogTask_RecoveryMode,def=0" json:"mode,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *SplitLogTask) Reset()                    { *m = SplitLogTask{} }
func (m *SplitLogTask) String() string            { return proto.CompactTextString(m) }
func (*SplitLogTask) ProtoMessage()               {}
func (*SplitLogTask) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{3} }

const Default_SplitLogTask_Mode SplitLogTask_RecoveryMode = SplitLogTask_UNKNOWN

func (m *SplitLogTask) GetState() SplitLogTask_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return SplitLogTask_UNASSIGNED
}

func (m *SplitLogTask) GetServerName() *ServerName {
	if m != nil {
		return m.ServerName
	}
	return nil
}

func (m *SplitLogTask) GetMode() SplitLogTask_RecoveryMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Default_SplitLogTask_Mode
}

// *
// The znode that holds state of table.
// Deprected, table state is stored in table descriptor on HDFS.
type DeprecatedTableState struct {
	// This is the table's state.  If no znode for a table,
	// its state is presumed enabled.  See o.a.h.h.zookeeper.ZKTable class
	// for more.
	State            *DeprecatedTableState_State `protobuf:"varint,1,req,name=state,enum=pb.DeprecatedTableState_State,def=0" json:"state,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *DeprecatedTableState) Reset()                    { *m = DeprecatedTableState{} }
func (m *DeprecatedTableState) String() string            { return proto.CompactTextString(m) }
func (*DeprecatedTableState) ProtoMessage()               {}
func (*DeprecatedTableState) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{4} }

const Default_DeprecatedTableState_State DeprecatedTableState_State = DeprecatedTableState_ENABLED

func (m *DeprecatedTableState) GetState() DeprecatedTableState_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return Default_DeprecatedTableState_State
}

// *
// State of the switch.
type SwitchState struct {
	Enabled          *bool  `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SwitchState) Reset()                    { *m = SwitchState{} }
func (m *SwitchState) String() string            { return proto.CompactTextString(m) }
func (*SwitchState) ProtoMessage()               {}
func (*SwitchState) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{5} }

func (m *SwitchState) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func init() {
	proto.RegisterType((*MetaRegionServer)(nil), "pb.MetaRegionServer")
	proto.RegisterType((*Master)(nil), "pb.Master")
	proto.RegisterType((*ClusterUp)(nil), "pb.ClusterUp")
	proto.RegisterType((*SplitLogTask)(nil), "pb.SplitLogTask")
	proto.RegisterType((*DeprecatedTableState)(nil), "pb.DeprecatedTableState")
	proto.RegisterType((*SwitchState)(nil), "pb.SwitchState")
	proto.RegisterEnum("pb.SplitLogTask_State", SplitLogTask_State_name, SplitLogTask_State_value)
	proto.RegisterEnum("pb.SplitLogTask_RecoveryMode", SplitLogTask_RecoveryMode_name, SplitLogTask_RecoveryMode_value)
	proto.RegisterEnum("pb.DeprecatedTableState_State", DeprecatedTableState_State_name, DeprecatedTableState_State_value)
}

var fileDescriptor27 = []byte{
	// 555 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x53, 0x5f, 0x8f, 0xd2, 0x4e,
	0x14, 0xfd, 0x4d, 0xd9, 0x5d, 0xe8, 0x2d, 0xf0, 0xc3, 0xf1, 0x4f, 0xc8, 0x9a, 0xd5, 0x4d, 0x1f,
	0x94, 0xa8, 0xa9, 0x91, 0x47, 0x12, 0x35, 0xb0, 0x6d, 0x58, 0xb2, 0xa5, 0x90, 0x29, 0x68, 0xf4,
	0x85, 0x14, 0x3a, 0x0b, 0x44, 0xe8, 0x34, 0x6d, 0xd1, 0xf8, 0x0d, 0xf6, 0x13, 0xf8, 0xec, 0x27,
	0xf0, 0x33, 0x7a, 0xa7, 0x43, 0x75, 0x37, 0xae, 0xf1, 0x85, 0xdc, 0x7b, 0xce, 0xe9, 0x3d, 0xe7,
	0xde, 0x30, 0xf0, 0xff, 0x47, 0x21, 0x2e, 0x38, 0x8f, 0x79, 0x62, 0xc5, 0x89, 0xc8, 0x04, 0xd5,
	0xe2, 0xf9, 0xb1, 0x71, 0xde, 0x0b, 0x52, 0xae, 0x80, 0xe3, 0xbb, 0x67, 0x9b, 0x5d, 0x9a, 0xf1,
	0xc4, 0xcf, 0x82, 0x6c, 0x97, 0x2a, 0xd0, 0xbc, 0x22, 0xd0, 0x18, 0xf2, 0x2c, 0x60, 0x7c, 0xb9,
	0x16, 0x91, 0xcf, 0x93, 0xcf, 0x3c, 0xa1, 0x4f, 0xe0, 0x28, 0xcd, 0xab, 0x26, 0x39, 0xd5, 0x5a,
	0x46, 0xbb, 0x6e, 0xc5, 0x73, 0x4b, 0x71, 0x5e, 0xb0, 0xe5, 0x6c, 0xcf, 0xd2, 0xc7, 0x60, 0x24,
	0xf1, 0x62, 0x86, 0x65, 0x8a, 0x1f, 0x37, 0xb5, 0x53, 0xd2, 0xaa, 0x31, 0x40, 0xe8, 0x9d, 0x42,
	0xe8, 0x73, 0x38, 0x4c, 0xd1, 0x8d, 0x37, 0x4b, 0x48, 0xd5, 0xdb, 0xf7, 0xe5, 0x9c, 0xbd, 0x93,
	0x84, 0xad, 0xfc, 0x97, 0x29, 0x8d, 0x19, 0xc1, 0xd1, 0x30, 0x90, 0x01, 0xa5, 0xff, 0x36, 0xaf,
	0xfe, 0xe6, 0xaf, 0xd8, 0x7f, 0xfb, 0x3f, 0x04, 0x7d, 0x1d, 0x5d, 0x8a, 0x59, 0x2c, 0x92, 0x2c,
	0xcf, 0x50, 0x63, 0x15, 0x09, 0x8c, 0xb1, 0x37, 0x9f, 0x81, 0xbe, 0xbf, 0xc8, 0x34, 0xa6, 0x27,
	0x00, 0x98, 0x22, 0xc9, 0x66, 0xa1, 0x8c, 0x2b, 0x6d, 0x75, 0xa6, 0xe7, 0x88, 0x2d, 0xb3, 0xfd,
	0xd0, 0xa0, 0xea, 0xc7, 0x9b, 0x75, 0xe6, 0x8a, 0xe5, 0x24, 0x48, 0x3f, 0xd1, 0x17, 0xc5, 0x66,
	0x52, 0x5a, 0x6f, 0x3f, 0xc8, 0x13, 0x5e, 0x13, 0xdc, 0x58, 0x8d, 0xbe, 0x04, 0x43, 0x9d, 0x6c,
	0x16, 0x61, 0x7e, 0x0c, 0x7a, 0xdb, 0x56, 0x90, 0xfe, 0xaa, 0x69, 0x07, 0x0e, 0xb6, 0x22, 0x2c,
	0xee, 0x76, 0xf2, 0xc7, 0x74, 0xc6, 0x17, 0x02, 0xb5, 0x5f, 0x87, 0x28, 0xea, 0x94, 0xa7, 0xde,
	0x85, 0x37, 0x7a, 0xef, 0xb1, 0xfc, 0x1b, 0xf3, 0x0c, 0x0e, 0x73, 0x73, 0x5a, 0x07, 0x98, 0x7a,
	0x5d, 0xdf, 0x1f, 0xf4, 0x3d, 0xc7, 0x6e, 0xfc, 0x47, 0x75, 0x38, 0x44, 0x15, 0x96, 0x84, 0x56,
	0xa1, 0xc2, 0x9c, 0x3d, 0xa1, 0xd1, 0x0a, 0x1c, 0xd8, 0x23, 0xcf, 0x69, 0x94, 0x68, 0x19, 0x4a,
	0x0e, 0x63, 0x8d, 0x03, 0xf3, 0x0d, 0x54, 0xaf, 0x7b, 0x50, 0x03, 0x0a, 0x17, 0x1c, 0x74, 0x07,
	0x6a, 0xee, 0xa8, 0x3f, 0xf3, 0xc7, 0xee, 0x60, 0x32, 0x19, 0x78, 0x7d, 0x1c, 0x88, 0x5e, 0x12,
	0x62, 0xce, 0xd8, 0xed, 0x7e, 0x68, 0x68, 0xe6, 0x37, 0x02, 0xf7, 0x6c, 0x1e, 0x27, 0x7c, 0x81,
	0x49, 0xc2, 0x49, 0x30, 0xdf, 0x70, 0x15, 0xea, 0xf5, 0xcd, 0xc3, 0x3d, 0x92, 0xab, 0xdd, 0x26,
	0x54, 0x07, 0xec, 0x94, 0x1d, 0xaf, 0xdb, 0x73, 0x1d, 0xbb, 0xf8, 0x93, 0xbc, 0x2d, 0x96, 0xc3,
	0x40, 0x7b, 0x0a, 0x03, 0xe1, 0x3a, 0xf6, 0xc0, 0x57, 0x1d, 0xa1, 0x35, 0xd0, 0x55, 0x27, 0xa3,
	0x69, 0x92, 0xcc, 0x95, 0xb2, 0x2b, 0x99, 0x4f, 0xc1, 0xf0, 0xbf, 0xac, 0xb3, 0xc5, 0x4a, 0x8d,
	0x69, 0x42, 0x99, 0x47, 0xd2, 0x34, 0xc4, 0x40, 0xa4, 0x55, 0x61, 0x45, 0xdb, 0x73, 0xe1, 0x95,
	0x48, 0x96, 0x56, 0x10, 0x07, 0x8b, 0x15, 0xb7, 0x56, 0x41, 0x28, 0x44, 0x6c, 0xad, 0xe6, 0xf2,
	0x3d, 0xa5, 0xd8, 0xf1, 0x50, 0xbd, 0xa0, 0xf9, 0xee, 0xd2, 0x5a, 0xf2, 0x88, 0x27, 0x32, 0x7e,
	0xef, 0xf7, 0x2b, 0x1c, 0x4b, 0x32, 0x3d, 0x27, 0x57, 0x84, 0x7c, 0x27, 0xe4, 0x67, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xb3, 0x45, 0x6a, 0x2a, 0x9f, 0x03, 0x00, 0x00,
}
