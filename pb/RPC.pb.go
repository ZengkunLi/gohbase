// Code generated by protoc-gen-go.
// source: RPC.proto
// DO NOT EDIT!

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// User Information proto.  Included in ConnectionHeader on connection setup
type UserInformation struct {
	EffectiveUser    *string `protobuf:"bytes,1,req,name=effective_user,json=effectiveUser" json:"effective_user,omitempty"`
	RealUser         *string `protobuf:"bytes,2,opt,name=real_user,json=realUser" json:"real_user,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserInformation) Reset()                    { *m = UserInformation{} }
func (m *UserInformation) String() string            { return proto.CompactTextString(m) }
func (*UserInformation) ProtoMessage()               {}
func (*UserInformation) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{0} }

func (m *UserInformation) GetEffectiveUser() string {
	if m != nil && m.EffectiveUser != nil {
		return *m.EffectiveUser
	}
	return ""
}

func (m *UserInformation) GetRealUser() string {
	if m != nil && m.RealUser != nil {
		return *m.RealUser
	}
	return ""
}

// This is sent on connection setup after the connection preamble is sent.
type ConnectionHeader struct {
	UserInfo    *UserInformation `protobuf:"bytes,1,opt,name=user_info,json=userInfo" json:"user_info,omitempty"`
	ServiceName *string          `protobuf:"bytes,2,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
	// Cell block codec we will use sending over optional cell blocks.  Server throws exception
	// if cannot deal.  Null means no codec'ing going on so we are pb all the time (SLOW!!!)
	CellBlockCodecClass *string `protobuf:"bytes,3,opt,name=cell_block_codec_class,json=cellBlockCodecClass" json:"cell_block_codec_class,omitempty"`
	// Compressor we will use if cell block is compressed.  Server will throw exception if not supported.
	// Class must implement hadoop's CompressionCodec Interface.  Can't compress if no codec.
	CellBlockCompressorClass *string      `protobuf:"bytes,4,opt,name=cell_block_compressor_class,json=cellBlockCompressorClass" json:"cell_block_compressor_class,omitempty"`
	VersionInfo              *VersionInfo `protobuf:"bytes,5,opt,name=version_info,json=versionInfo" json:"version_info,omitempty"`
	// the transformation for rpc AES encryption with Apache Commons Crypto
	RpcCryptoCipherTransformation *string `protobuf:"bytes,6,opt,name=rpc_crypto_cipher_transformation,json=rpcCryptoCipherTransformation" json:"rpc_crypto_cipher_transformation,omitempty"`
	XXX_unrecognized              []byte  `json:"-"`
}

func (m *ConnectionHeader) Reset()                    { *m = ConnectionHeader{} }
func (m *ConnectionHeader) String() string            { return proto.CompactTextString(m) }
func (*ConnectionHeader) ProtoMessage()               {}
func (*ConnectionHeader) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{1} }

func (m *ConnectionHeader) GetUserInfo() *UserInformation {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *ConnectionHeader) GetServiceName() string {
	if m != nil && m.ServiceName != nil {
		return *m.ServiceName
	}
	return ""
}

func (m *ConnectionHeader) GetCellBlockCodecClass() string {
	if m != nil && m.CellBlockCodecClass != nil {
		return *m.CellBlockCodecClass
	}
	return ""
}

func (m *ConnectionHeader) GetCellBlockCompressorClass() string {
	if m != nil && m.CellBlockCompressorClass != nil {
		return *m.CellBlockCompressorClass
	}
	return ""
}

func (m *ConnectionHeader) GetVersionInfo() *VersionInfo {
	if m != nil {
		return m.VersionInfo
	}
	return nil
}

func (m *ConnectionHeader) GetRpcCryptoCipherTransformation() string {
	if m != nil && m.RpcCryptoCipherTransformation != nil {
		return *m.RpcCryptoCipherTransformation
	}
	return ""
}

// This is sent by rpc server to negotiate the data if necessary
type ConnectionHeaderResponse struct {
	// To use Apache Commons Crypto, negotiate the metadata
	CryptoCipherMeta *CryptoCipherMeta `protobuf:"bytes,1,opt,name=crypto_cipher_meta,json=cryptoCipherMeta" json:"crypto_cipher_meta,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *ConnectionHeaderResponse) Reset()                    { *m = ConnectionHeaderResponse{} }
func (m *ConnectionHeaderResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectionHeaderResponse) ProtoMessage()               {}
func (*ConnectionHeaderResponse) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{2} }

func (m *ConnectionHeaderResponse) GetCryptoCipherMeta() *CryptoCipherMeta {
	if m != nil {
		return m.CryptoCipherMeta
	}
	return nil
}

// Optional Cell block Message.  Included in client RequestHeader
type CellBlockMeta struct {
	// Length of the following cell block.  Could calculate it but convenient having it too hand.
	Length           *uint32 `protobuf:"varint,1,opt,name=length" json:"length,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CellBlockMeta) Reset()                    { *m = CellBlockMeta{} }
func (m *CellBlockMeta) String() string            { return proto.CompactTextString(m) }
func (*CellBlockMeta) ProtoMessage()               {}
func (*CellBlockMeta) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{3} }

func (m *CellBlockMeta) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

// At the RPC layer, this message is used to carry
// the server side exception to the RPC client.
type ExceptionResponse struct {
	// Class name of the exception thrown from the server
	ExceptionClassName *string `protobuf:"bytes,1,opt,name=exception_class_name,json=exceptionClassName" json:"exception_class_name,omitempty"`
	// Exception stack trace from the server side
	StackTrace *string `protobuf:"bytes,2,opt,name=stack_trace,json=stackTrace" json:"stack_trace,omitempty"`
	// Optional hostname.  Filled in for some exceptions such as region moved
	// where exception gives clue on where the region may have moved.
	Hostname *string `protobuf:"bytes,3,opt,name=hostname" json:"hostname,omitempty"`
	Port     *int32  `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
	// Set if we are NOT to retry on receipt of this exception
	DoNotRetry       *bool  `protobuf:"varint,5,opt,name=do_not_retry,json=doNotRetry" json:"do_not_retry,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ExceptionResponse) Reset()                    { *m = ExceptionResponse{} }
func (m *ExceptionResponse) String() string            { return proto.CompactTextString(m) }
func (*ExceptionResponse) ProtoMessage()               {}
func (*ExceptionResponse) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{4} }

func (m *ExceptionResponse) GetExceptionClassName() string {
	if m != nil && m.ExceptionClassName != nil {
		return *m.ExceptionClassName
	}
	return ""
}

func (m *ExceptionResponse) GetStackTrace() string {
	if m != nil && m.StackTrace != nil {
		return *m.StackTrace
	}
	return ""
}

func (m *ExceptionResponse) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *ExceptionResponse) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *ExceptionResponse) GetDoNotRetry() bool {
	if m != nil && m.DoNotRetry != nil {
		return *m.DoNotRetry
	}
	return false
}

// *
// Cipher meta for Crypto
type CryptoCipherMeta struct {
	Transformation   *string `protobuf:"bytes,1,req,name=transformation" json:"transformation,omitempty"`
	InKey            []byte  `protobuf:"bytes,2,opt,name=inKey" json:"inKey,omitempty"`
	InIv             []byte  `protobuf:"bytes,3,opt,name=inIv" json:"inIv,omitempty"`
	OutKey           []byte  `protobuf:"bytes,4,opt,name=outKey" json:"outKey,omitempty"`
	OutIv            []byte  `protobuf:"bytes,5,opt,name=outIv" json:"outIv,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CryptoCipherMeta) Reset()                    { *m = CryptoCipherMeta{} }
func (m *CryptoCipherMeta) String() string            { return proto.CompactTextString(m) }
func (*CryptoCipherMeta) ProtoMessage()               {}
func (*CryptoCipherMeta) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{5} }

func (m *CryptoCipherMeta) GetTransformation() string {
	if m != nil && m.Transformation != nil {
		return *m.Transformation
	}
	return ""
}

func (m *CryptoCipherMeta) GetInKey() []byte {
	if m != nil {
		return m.InKey
	}
	return nil
}

func (m *CryptoCipherMeta) GetInIv() []byte {
	if m != nil {
		return m.InIv
	}
	return nil
}

func (m *CryptoCipherMeta) GetOutKey() []byte {
	if m != nil {
		return m.OutKey
	}
	return nil
}

func (m *CryptoCipherMeta) GetOutIv() []byte {
	if m != nil {
		return m.OutIv
	}
	return nil
}

// Header sent making a request.
type RequestHeader struct {
	// Monotonically increasing call_id to keep track of RPC requests and their response
	CallId     *uint32   `protobuf:"varint,1,opt,name=call_id,json=callId" json:"call_id,omitempty"`
	TraceInfo  *RPCTInfo `protobuf:"bytes,2,opt,name=trace_info,json=traceInfo" json:"trace_info,omitempty"`
	MethodName *string   `protobuf:"bytes,3,opt,name=method_name,json=methodName" json:"method_name,omitempty"`
	// If true, then a pb Message param follows.
	RequestParam *bool `protobuf:"varint,4,opt,name=request_param,json=requestParam" json:"request_param,omitempty"`
	// If present, then an encoded data block follows.
	CellBlockMeta *CellBlockMeta `protobuf:"bytes,5,opt,name=cell_block_meta,json=cellBlockMeta" json:"cell_block_meta,omitempty"`
	// 0 is NORMAL priority.  200 is HIGH.  If no priority, treat it as NORMAL.
	// See HConstants.
	Priority         *uint32 `protobuf:"varint,6,opt,name=priority" json:"priority,omitempty"`
	Timeout          *uint32 `protobuf:"varint,7,opt,name=timeout" json:"timeout,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RequestHeader) Reset()                    { *m = RequestHeader{} }
func (m *RequestHeader) String() string            { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()               {}
func (*RequestHeader) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{6} }

func (m *RequestHeader) GetCallId() uint32 {
	if m != nil && m.CallId != nil {
		return *m.CallId
	}
	return 0
}

func (m *RequestHeader) GetTraceInfo() *RPCTInfo {
	if m != nil {
		return m.TraceInfo
	}
	return nil
}

func (m *RequestHeader) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *RequestHeader) GetRequestParam() bool {
	if m != nil && m.RequestParam != nil {
		return *m.RequestParam
	}
	return false
}

func (m *RequestHeader) GetCellBlockMeta() *CellBlockMeta {
	if m != nil {
		return m.CellBlockMeta
	}
	return nil
}

func (m *RequestHeader) GetPriority() uint32 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *RequestHeader) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

type ResponseHeader struct {
	CallId *uint32 `protobuf:"varint,1,opt,name=call_id,json=callId" json:"call_id,omitempty"`
	// If present, then request threw an exception and no response message (else we presume one)
	Exception *ExceptionResponse `protobuf:"bytes,2,opt,name=exception" json:"exception,omitempty"`
	// If present, then an encoded data block follows.
	CellBlockMeta    *CellBlockMeta `protobuf:"bytes,3,opt,name=cell_block_meta,json=cellBlockMeta" json:"cell_block_meta,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ResponseHeader) Reset()                    { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string            { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()               {}
func (*ResponseHeader) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{7} }

func (m *ResponseHeader) GetCallId() uint32 {
	if m != nil && m.CallId != nil {
		return *m.CallId
	}
	return 0
}

func (m *ResponseHeader) GetException() *ExceptionResponse {
	if m != nil {
		return m.Exception
	}
	return nil
}

func (m *ResponseHeader) GetCellBlockMeta() *CellBlockMeta {
	if m != nil {
		return m.CellBlockMeta
	}
	return nil
}

func init() {
	proto.RegisterType((*UserInformation)(nil), "pb.UserInformation")
	proto.RegisterType((*ConnectionHeader)(nil), "pb.ConnectionHeader")
	proto.RegisterType((*ConnectionHeaderResponse)(nil), "pb.ConnectionHeaderResponse")
	proto.RegisterType((*CellBlockMeta)(nil), "pb.CellBlockMeta")
	proto.RegisterType((*ExceptionResponse)(nil), "pb.ExceptionResponse")
	proto.RegisterType((*CryptoCipherMeta)(nil), "pb.CryptoCipherMeta")
	proto.RegisterType((*RequestHeader)(nil), "pb.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "pb.ResponseHeader")
}

var fileDescriptor23 = []byte{
	// 738 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x54, 0xcd, 0x6e, 0xdb, 0x38,
	0x10, 0x86, 0x9c, 0x38, 0xb1, 0xc7, 0x56, 0x7e, 0x98, 0x6c, 0xd6, 0x48, 0xb0, 0x58, 0xaf, 0x16,
	0xbb, 0x1b, 0x60, 0x01, 0x23, 0x4d, 0x4e, 0x3d, 0xf4, 0x62, 0xa1, 0x68, 0x82, 0xa2, 0x41, 0x40,
	0x24, 0x3d, 0x56, 0xa0, 0xa5, 0xb1, 0x2d, 0xd4, 0x16, 0x55, 0x8a, 0x36, 0xea, 0x77, 0xe8, 0xa9,
	0xb7, 0xde, 0xfa, 0x18, 0x7d, 0x94, 0x3e, 0x4e, 0xc9, 0xa1, 0xe4, 0xd8, 0x6e, 0x81, 0xf6, 0xc6,
	0xf9, 0x66, 0x86, 0x9c, 0xf9, 0xbe, 0x4f, 0x82, 0x26, 0xbf, 0x0b, 0x7b, 0xb9, 0x92, 0x5a, 0xb2,
	0x5a, 0x3e, 0x38, 0xf5, 0xef, 0x95, 0x88, 0xd3, 0x6c, 0xe4, 0xa0, 0xd3, 0xd6, 0x75, 0x5f, 0x14,
	0xe8, 0x82, 0xe0, 0x01, 0xf6, 0x1f, 0x0a, 0x54, 0x37, 0xd9, 0x50, 0xaa, 0xa9, 0xd0, 0xa9, 0xcc,
	0xd8, 0x3f, 0xb0, 0x87, 0xc3, 0x21, 0xc6, 0x3a, 0x9d, 0x63, 0x34, 0x33, 0xc9, 0x8e, 0xd7, 0xad,
	0x9d, 0x37, 0xb9, 0xbf, 0x44, 0x6d, 0x07, 0x3b, 0x83, 0xa6, 0x42, 0x31, 0x71, 0x15, 0xb5, 0xae,
	0x67, 0x2a, 0x1a, 0x16, 0xb0, 0xc9, 0xe0, 0x6b, 0x0d, 0x0e, 0x42, 0x99, 0x65, 0xb6, 0x5e, 0x66,
	0xd7, 0x28, 0x12, 0xd3, 0x71, 0x01, 0x4d, 0x5b, 0x1c, 0xa5, 0xe6, 0x31, 0x73, 0xa7, 0x77, 0xde,
	0xba, 0x3c, 0xea, 0xe5, 0x83, 0xde, 0xc6, 0x00, 0xbc, 0x31, 0x2b, 0x01, 0xf6, 0x17, 0xb4, 0xcd,
	0x71, 0x9e, 0xc6, 0x18, 0x65, 0x62, 0x8a, 0xe5, 0x33, 0xad, 0x12, 0xbb, 0x35, 0x10, 0xbb, 0x82,
	0x93, 0x18, 0x27, 0x93, 0x68, 0x30, 0x91, 0xf1, 0xdb, 0x28, 0x96, 0x09, 0xc6, 0x51, 0x3c, 0x11,
	0x45, 0xd1, 0xd9, 0xa2, 0xe2, 0x23, 0x9b, 0xed, 0xdb, 0x64, 0x68, 0x73, 0xa1, 0x4d, 0xb1, 0x67,
	0x70, 0xb6, 0xd6, 0x34, 0xcd, 0x15, 0x16, 0x85, 0x54, 0x65, 0xe7, 0x36, 0x75, 0x76, 0x56, 0x3a,
	0xab, 0x02, 0xd7, 0x7e, 0x09, 0xed, 0x39, 0xaa, 0xc2, 0xcc, 0xea, 0x76, 0xa9, 0xd3, 0x2e, 0xfb,
	0x76, 0x97, 0xd7, 0x0e, 0xb7, 0xd3, 0xf3, 0xd6, 0xfc, 0x31, 0x60, 0x2f, 0xa0, 0xab, 0x72, 0x33,
	0x9a, 0x5a, 0xe4, 0x5a, 0x46, 0x71, 0x9a, 0x8f, 0x0d, 0x13, 0x5a, 0x89, 0xac, 0x58, 0x2e, 0xde,
	0xd9, 0xa1, 0x77, 0xff, 0x30, 0x75, 0x21, 0x95, 0x85, 0x54, 0x75, 0xbf, 0x56, 0x14, 0xbc, 0x81,
	0xce, 0x26, 0xb3, 0x1c, 0x8b, 0x5c, 0x66, 0x05, 0xb2, 0x3e, 0xb0, 0xf5, 0x07, 0xa6, 0xa8, 0x45,
	0x49, 0xf5, 0xb1, 0x1d, 0x6f, 0xf5, 0xde, 0x57, 0x26, 0xc7, 0x0f, 0xe2, 0x0d, 0x24, 0xf8, 0x0f,
	0xfc, 0xb0, 0x5a, 0xdc, 0x02, 0xec, 0x04, 0x76, 0x26, 0x98, 0x8d, 0xf4, 0x98, 0x2e, 0xf2, 0x79,
	0x19, 0x05, 0x5f, 0x3c, 0x38, 0x7c, 0xfe, 0x3e, 0xc6, 0x9c, 0x44, 0xab, 0x46, 0xb8, 0x80, 0x63,
	0xac, 0x40, 0x47, 0xa7, 0x93, 0xce, 0xa3, 0xdd, 0xd8, 0x32, 0x47, 0x4c, 0x92, 0x82, 0x7f, 0x42,
	0xab, 0xd0, 0xc2, 0xe8, 0x60, 0xd8, 0x88, 0x2b, 0x8d, 0x81, 0x20, 0x6b, 0x5c, 0x64, 0xa7, 0xd0,
	0x18, 0xcb, 0x42, 0xd3, 0x35, 0x4e, 0xd4, 0x65, 0xcc, 0x18, 0x6c, 0xe7, 0x52, 0x69, 0x92, 0xac,
	0xce, 0xe9, 0xcc, 0xba, 0xd0, 0x4e, 0x64, 0x94, 0x49, 0x1d, 0x29, 0xd4, 0x6a, 0x41, 0xf2, 0x34,
	0x38, 0x24, 0xf2, 0x56, 0x6a, 0x6e, 0x91, 0xe0, 0xa3, 0x67, 0xec, 0xb9, 0xb1, 0x38, 0xfb, 0x17,
	0xf6, 0x36, 0xf4, 0x70, 0xbe, 0xdf, 0x40, 0xd9, 0x31, 0xd4, 0xd3, 0xec, 0x25, 0x2e, 0x68, 0xd2,
	0x36, 0x77, 0x81, 0x1d, 0x24, 0xcd, 0x6e, 0xe6, 0x34, 0x60, 0x9b, 0xd3, 0xd9, 0x32, 0x27, 0x67,
	0xda, 0x96, 0x6e, 0x13, 0x5a, 0x46, 0xf6, 0x06, 0x73, 0x32, 0xc5, 0x75, 0x77, 0x03, 0x05, 0xc1,
	0x87, 0x1a, 0xf8, 0x1c, 0xdf, 0xcd, 0xb0, 0xd0, 0xe5, 0x07, 0xf3, 0x3b, 0xec, 0xc6, 0xc2, 0xd8,
	0x34, 0x4d, 0x2a, 0xea, 0x6d, 0x78, 0x93, 0xb0, 0xff, 0x01, 0x88, 0x2c, 0x67, 0xbf, 0x1a, 0xe9,
	0xdb, 0xb6, 0xfa, 0x9a, 0x0f, 0xff, 0x9e, 0xbc, 0xd7, 0xa4, 0x3c, 0x39, 0xcf, 0xf0, 0x6b, 0x6c,
	0x30, 0x96, 0x49, 0xb4, 0xc2, 0x20, 0x38, 0x88, 0x04, 0xf8, 0x1b, 0x7c, 0xe5, 0xde, 0x8d, 0x72,
	0xa1, 0xc4, 0x94, 0xa6, 0x6d, 0xf0, 0x76, 0x09, 0xde, 0x59, 0x8c, 0x3d, 0x85, 0xfd, 0x95, 0x4f,
	0x86, 0x7c, 0xe5, 0x6c, 0x7f, 0x48, 0xbe, 0x5a, 0x75, 0x0c, 0xf7, 0xe3, 0x35, 0x03, 0x19, 0xfd,
	0x72, 0x95, 0x4a, 0x95, 0xea, 0x05, 0x59, 0xdc, 0xe7, 0xcb, 0x98, 0x75, 0x60, 0x57, 0xa7, 0x53,
	0x34, 0x0c, 0x74, 0x76, 0x29, 0x55, 0x85, 0xc1, 0x27, 0x0f, 0xf6, 0x2a, 0x57, 0xfd, 0x8c, 0x8f,
	0x2b, 0x68, 0x2e, 0x8d, 0x55, 0xd2, 0xf1, 0x9b, 0x1d, 0xeb, 0x3b, 0x7b, 0xf2, 0xc7, 0xba, 0x1f,
	0x6d, 0xb4, 0xf5, 0x6b, 0x1b, 0xf5, 0x43, 0x78, 0x22, 0xd5, 0xa8, 0x27, 0x72, 0x11, 0x8f, 0xb1,
	0x37, 0x16, 0x89, 0x94, 0x79, 0x6f, 0x3c, 0xb0, 0xbf, 0xd5, 0xc2, 0x44, 0x98, 0xb8, 0xbf, 0xeb,
	0x60, 0x36, 0xec, 0x8d, 0x30, 0x43, 0x25, 0x34, 0x26, 0x7d, 0xfb, 0x57, 0xbe, 0xb3, 0x70, 0x71,
	0xed, 0x7d, 0xf6, 0xbc, 0x6f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x69, 0x4d, 0x0c, 0xe8, 0xa6, 0x05,
	0x00, 0x00,
}
